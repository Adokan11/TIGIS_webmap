<!DOCTYPE html>
<html>
<head>
    <title>Webmap dev blah</title>
    <link rel = 'stylesheet' href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css'/>
    <style>
        body {margin:0; font-family: Arial, sans-serif}
        #map {height: 100vh}
        label {display: block; margin: 8px 0; font-weight: bold}
        input[type = 'checkbox'] {cursor: pointer}
        .controls button:hover {background: #661a40}
        .controls {
            position: absolute; top: 0; left: 0; bottom: 0; z-index: 1000;
            background: #f5f5f5; padding: 15px; 
            box-shadow: 0 0 15px #00000040; 
            width: 250px; overflow-y: auto;
        }
        .controls button {
            width: 100%; 
            padding: 8px; 
            background: #882255; 
            color: white; 
            border: none; 
            border-radius: 4px; 
            cursor: pointer;
            font-weight: bold;
        }
        .layer-indent {
            margin-left: 20px;
            display: none;
        }
        .layer-indent.visible {
            display: block;
        }
        .leaflet-popup-close-button:hover {color: #ff0000 !important;}
        .leaflet-popup-close-button {
            font-size: 20px !important;
            font-weight: bold !important;
            color: #000 !important;
            padding: 4px 8px !important;
        }
        #site-search {
            width: 100%; 
            padding: 8px; 
            margin-bottom: 8px; 
            box-sizing: border-box;
        }
        .site-details{
            position: absolute; bottom: 10px; right: 10px; z-index: 1000;
            background: #f5f5f5; padding: 15px; border-radius: 8px;
            box-shadow: 0 0 15px #00000040; max-width: 350px;
            display: none;
        }
        .site-details.active{display: block; border-radius: 15px; border: 4px solid #882255}
        .site-details h3 {margin-top: 0; color: #882255} 
        .site-details .close-btn {
            float: inline-end; cursor: pointer; font-size: 20px;
            color: #000; font-weight: bold;
        }
        .site-details .close-btn:hover {color: #ff0000}
        .detail-section {margin: 10px 0; padding: 8px; border-radius: 15px; border: 4px solid}
        .detail-section h4 {margin: 0 0 8px 0; font-size: 14px}
        .detail-row {display: flex; justify-content: space-between; margin: 4px 0; font-size: 13px}
        .detail-label {font-weight: bold; color: #555}
        .detail-value {color: #333}
        .rank-colorbar {
            display: flex; 
            height: 20px; 
            border-radius: 4px; 
            margin: 8px 0; 
            box-shadow: inset 0 0 5px #00000020;
        }
        .rank-colorbar-segment {
            flex: 1;
        }
        .rank-colorbar-segment:last-child {
            border-right: none;
        }
        .rank-legend {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-top: 4px;
        }
    </style>
</head>
<body>

<!-- Layer control panel -->
<div class = 'controls'>
    <h2>Webmap blah</h2>
    <p>Description ... blah blah blah</p>
    <h3>Layers</h3>
    {% for layer in layers %}
    {% if layer == 'buffers' %}
    <label class = 'layer-indent' id = 'buffers-toggle'>
        <input type = 'checkbox' checked onclick = 'toggle("{{ layer }}")' data-layer = '{{ layer }}'>
        <span class = 'layer-label' data-layer = '{{ layer }}'>{{ layer.replace('_', ' ') | title }}</span>
    </label>
    {% elif layer == 'spaces' %}
    <label>
        <input type = 'checkbox' checked onclick = 'toggleSpaces()' data-layer = '{{ layer }}'>
        <span class = 'layer-label' data-layer = '{{ layer }}'>{{ layer.replace('_', ' ') | title }}</span>
    </label>
    <h4 style = 'margin-bottom: 5px; margin-top: 5px; display: none;' id = 'types-heading'>Types:</h4>
    {% for space_type in space_types %}
    <label class = 'layer-indent space-type' id = 'space-type-{{ loop.index }}'>
        <input type = 'checkbox' checked onclick = 'toggleSpaceType("{{ space_type }}")' 
               data-type = '{{ space_type }}'>
        <span style = 'color: #117733; font-weight: bold;'>{{ space_type }}</span>
    </label>
    {% endfor %}
    {% else %}
    <label>
        <input type = 'checkbox' checked onclick = 'toggle("{{ layer }}")' data-layer = '{{ layer }}'>
        <span class = 'layer-label' data-layer = '{{ layer }}'>{{ layer.replace('_', ' ') | title }}</span>
    </label>
    {% if layer == 'sites' %}
    <label class = 'layer-indent' id = 'rank-coloring-toggle' style = 'display: none;'>
        <input type = 'checkbox' onclick = 'toggleRankColoring()' id = 'rank-coloring-checkbox'>
        <span style = 'color: #882255; font-weight: bold;'>Color by Rank</span>
    </label>
    <div id = 'rank-colorbar-container' class = 'layer-indent' style = 'display: none; margin-bottom: 10px;'>
        <div class = 'rank-colorbar' id = 'rank-colorbar'></div>
        <div class = 'rank-legend'>
            <span>Worst (65)</span>
            <span>Best (1)</span>
        </div>
    </div>
    {% endif %}
    {% endif %}
    {% endfor %}
    <h3>Find Sites</h3>
    <h4>Filters</h4>
    <h5 style = 'margin-bottom: 3px;'>Final Score</h5>
    <div style = 'display: flex; gap: 10px; margin-bottom: 10px;'>
        <div style = 'flex: 1;'>
            <label for = 'score-min' style = 'font-weight: normal;'>Min: <span id = 'min-value'>0.00</span></label>
            <input type = 'range' id = 'score-min' min = '0' max = '1' step = '0.01' value = '0' 
                   style = 'width: 100%; cursor: pointer;' oninput = 'updateScoreFilter()'>
        </div>
        <div style = 'flex: 1;'>
            <label for = 'score-max' style = 'font-weight: normal;'>Max: <span id = 'max-value'>1.00</span></label>
            <input type = 'range' id = 'score-max' min = '0' max = '1' step = '0.01' value = '1' 
                   style = 'width: 100%; cursor: pointer;' oninput = 'updateScoreFilter()'>
        </div>
    </div>
        <h5 style = 'margin-bottom: 5px;'>Buffer's Population</h5>
    <div style = 'display: flex; gap: 10px; margin-bottom: 10px;'>
        <div style = 'flex: 1;'>
            <label for = 'pop-min' style = 'font-weight: normal;'>Min: <span id = 'pop-min-value'>0</span></label>
            <input type = 'range' id = 'pop-min' min = '0' max = '30000' step = '200' value = '0' 
                   style = 'width: 100%; cursor: pointer;' oninput = 'updatePopulationFilter()'>
        </div>
        <div style = 'flex: 1;'>
            <label for = 'pop-max' style = 'font-weight: normal;'>Max: <span id = 'pop-max-value'>30000</span></label>
            <input type = 'range' id = 'pop-max' min = '0' max = '30000' step = '200' value = '30000' 
                   style = 'width: 100%; cursor: pointer;' oninput = 'updatePopulationFilter()'>
        </div>
    </div>
    <button onclick = 'resetScoreFilter()' style = 'background: #aaa; margin-bottom: 15px;'>Reset Filters</button>
    <input type = 'text' id = 'site-search' placeholder = 'Search by name'>
    <button onclick = 'searchSites()'>Search</button>
</div>

<!-- Site details panel -->
<div class = 'site-details' id = 'site-details'>
    <span class = 'close-btn' onclick = 'clearSelection()'>&times;</span>
    <div id = 'details-content'></div>
</div>

<div id = 'map'></div>

<script src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js'></script>
<script>

    // Define all layer styles and labels in one place
    const LAYER_CONFIG = {
        buffers: {
            defaultOn: false,
            label: 'All Buffers',
            color: '#332288',
            background: '#33228830',
            weight: 2,
            fillOpacity: 0.15},
        spaces: {
            defaultOn: false,
            label: 'All Green Spaces',
            color: '#117733',
            background: '#11773330',
            weight: 2,
            fillOpacity: 0.15},
        sites: {
            defaultOn: true,
            label: 'Sites',
            color: '#882255',
            background: '#88225530',
            radius: 7,
            bigradius: 10,
            fillOpacity: 0.5},
        ccs: {
            defaultOn: false,
            label: 'All Community Centres',
            color: '#999933',
            background: '#99993330',
            radius: 7,
            bigradius: 10,
            fillOpacity: 0.5}
    }

    // Initialize the map centered on Edinburgh
    const map = L.map('map').setView([55.94, -3.24], 12)
    map.zoomControl.setPosition('topright');

    // Add OpenStreetMap base layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy OpenStreetMap contributors'}).addTo(map)
    
    // Create a custom pane for sites with higher z-index
    map.createPane('sitesPane')
    map.getPane('sitesPane').style.zIndex = 650
    
    // Track currently active layers
    const activeLayers = {}

    // Store full layer data (to avoid refetching)
    const layersData = {}

    // Track active space types
    const activeSpaceTypes = new Set()

    // Sites-specific filter term
    let sitesFilter = ''
    
    // Track selected site
    let selectedSite = null
    let selectedSiteLayer = null
    let highlightedLayers = {}

    // Sites-specific filter term
    let sitesFilterScore = ''
    
    // Score range filter
    let scoreMin = 0
    let scoreMax = 1

    // Track rank coloring state
    let rankColoringEnabled = false

    // Store plasma colormap
    let plasmaData = null

    // Population range filter
    let populationMin = 0
    let populationMax = 30000
    
    // Create a map of site DES_REF to buffer population for quick lookup
    let siteBufferPopulation = {}

        /**
     * Update population filter values and refresh sites layer
     */
    function updatePopulationFilter() {
        populationMin = parseFloat(document.getElementById('pop-min').value)
        populationMax = parseFloat(document.getElementById('pop-max').value)
        
        // Ensure min doesn't exceed max and vice versa
        if (populationMin > populationMax) {
            [populationMin, populationMax] = [populationMax, populationMin]
            document.getElementById('pop-min').value = populationMin
            document.getElementById('pop-max').value = populationMax
        }
        
        document.getElementById('pop-min-value').textContent = populationMin.toLocaleString()
        document.getElementById('pop-max-value').textContent = populationMax.toLocaleString()
        
        // Refresh sites layer if active
        if (activeLayers['sites']) {
            map.removeLayer(activeLayers['sites'])
            delete activeLayers['sites']
            createLayer('sites')
        }
    }

    /**
     * Build lookup map of site to buffer population
     */
    function buildBufferPopulationMap() {
        if (layersData['buffers']) {
            layersData['buffers'].features.forEach(feature => {
                const desRef = feature.properties.DES_REF
                const population = feature.properties.Population || 0
                siteBufferPopulation[desRef] = population
            })
        }
    }

    /**
     * Get color based on site rank (1-65)
     * Using matplotlib plasma colormap from server
     */
    function getRankColor(rank) {
        if (!rank || !plasmaData) return 'rgb(13, 8, 135)'
        
        // Normalize rank to 0-1 (1 = 0, 65 = 1)
        // Invert so rank 1 (best) gets the end of the colormap (yellow)
        const normalized = (65 - rank) / 64
        
        // Find the closest entry in the lookup table
        const index = Math.round(normalized * (plasmaData.length - 1))
        const [r, g, b] = plasmaData[index]
        
        return `rgb(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)})`
    }

    /**
     * Toggle rank-based coloring for sites
     */
    function toggleRankColoring() {
        rankColoringEnabled = document.getElementById('rank-coloring-checkbox').checked
        const rankColorbar = document.getElementById('rank-colorbar-container')
        
        // Show/hide colorbar based on checkbox state
        rankColorbar.style.display = rankColoringEnabled ? 'block' : 'none'
        
        // Recreate sites layer with new coloring
        if (activeLayers['sites']) {
            map.removeLayer(activeLayers['sites'])
            delete activeLayers['sites']
            createLayer('sites')
        }
    }

    /**
     * Generate colorbar gradient
     */
    function generateRankColorbar() {
        const container = document.getElementById('rank-colorbar')
        container.innerHTML = ''
        
        for (let i = 65; i >= 1; i--) {
            const segment = document.createElement('div')
            segment.className = 'rank-colorbar-segment'
            segment.style.backgroundColor = getRankColor(i)
            container.appendChild(segment)
        }
    }
    
    /**
     * Handle site selection
     */
    function selectSite(desRef, layer) {
        // Clear previous selection
        if (selectedSiteLayer) {
        map.removeLayer(selectedSiteLayer)
        selectedSiteLayer = null
        }
        
        // Create a new highlighted circle for the selected site
        const latlng = layer.getLatLng()
        selectedSiteLayer = L.circleMarker(latlng, {
            ...LAYER_CONFIG.sites,
            fillOpacity: 1,
            radius: LAYER_CONFIG.sites.bigradius,
            pane: 'sitesPane'
        }).addTo(map)
        
        selectedSite = desRef
        
        // Ensure required layers are loaded before fetching site details
        const requiredLayers = ['buffers', 'spaces', 'ccs']
        const loadPromises = requiredLayers.map(layerName => {
            if (!layersData[layerName]) {
                return fetch(`/layer/${layerName}`)
                    .then(r => r.json())
                    .then(data => {
                        layersData[layerName] = data
                    })
            }
            return Promise.resolve()
        })
        
        // Wait for all required layers to load, then fetch site details
        Promise.all(loadPromises)
            .then(() => fetch(`/site_details/${desRef}`))
            .then(r => r.json())
            .then(data => {
                displaySiteDetails(data)
                highlightRelatedFeatures(data)
            })
            .catch(err => {
                console.error('Error fetching site details:', err)
                alert('Error loading site details')
            })
    }

    /**
     * Add popup and hover functionality to a layer feature
     */
    function addFeatureInteractivity(feature, layer, layerName, highlight = true) {
        const style = LAYER_CONFIG[layerName]
        
        // Add hover effect
        if (highlight) {
            const hoverOpacity = layerName === 'ccs' ? 1 : 0.4
            layer.on('mouseover', function() {this.setStyle({fillOpacity: hoverOpacity})})
            layer.on('mouseout', function() {this.setStyle({fillOpacity: style.fillOpacity})})
        }
        
        // Add popup
        const popupContent = infoPopup(feature.properties, layerName)
        layer.bindPopup(popupContent, {
            className: `custom-popup-${layerName}`,
        })
        layer.on('popupopen', (e) => {
            const el = e.popup.getElement()
            if (el) {
                el.style.border = `4px solid ${style.color}`
                el.style.borderRadius = '15px'
            }
        })
    }

    /**
     * Display site details in the panel
     */
    function displaySiteDetails(details) {
        const panel = document.getElementById('site-details')
        const content = document.getElementById('details-content')
        
        let html = `<h3>${details.site_info.ENT_TITLE}</h3>`

        // basic site info
        html += `<div class = 'detail-section' style = 'border-color: ${LAYER_CONFIG.sites.color}; 
            color: ${LAYER_CONFIG.sites.color}; background: ${LAYER_CONFIG.sites.background}'>
            <div class = 'detail-row'>
                <span class = 'detail-label'>Final Score:</span>
                <span class = 'detail-value'>${details.site_info.FINAL_SCORE?.toLocaleString() || 'N/A'}</span>
            </div>
            <div class = 'detail-row'>
                <span class = 'detail-label'>Site Rank:</span>
                <span class = 'detail-value'>${details.site_info.RANK?.toLocaleString()}/65</span>
            </div>
            <div class = 'detail-row'>
                <span class = 'detail-label'>Designated:</span>
                <span class = 'detail-value'>${details.site_info.DESIGNATED || 'N/A'}</span>
            </div>
            <div class = 'detail-row'>
                <span class = 'detail-label'>Ref:</span>
                <span class = 'detail-value'>${details.site_info.DES_REF || 'N/A'}</span>
            </div>
            <div class = 'detail-row'>
                <a href='${details.site_info.LINK}' target = '_blank'>Site Website</a>
            </div>
         </div>`
        
        //buffer zone
        html += `<div class = 'detail-section' style = 'border-color: ${LAYER_CONFIG.buffers.color}; 
            color: ${LAYER_CONFIG.buffers.color}; background: ${LAYER_CONFIG.buffers.background}'>
            <h4>Buffer Zone:</h4>
            <div class = 'detail-row'>
                <span class = 'detail-label'>Population:</span>
                <span class = 'detail-value'>${details.site_catchment.POPULATION?.toLocaleString() || 'N/A'}</span>
            </div>
            <div class = 'detail-row'>
                <span class = 'detail-label'>Bus Routes:</span>
                <span class = 'detail-value'>${details.site_catchment.NUM_BUS_ROUTES || 0}</span>
            </div>
            <h4>SIMD Ranks:</h4>
            <div class = 'detail-row'>
                <span class = 'detail-label'>Average Rank:</span>
                <span class = 'detail-value'>${Math.round(details.simd_score.COMP_SIMD || 0).toLocaleString()}</span>
            </div>
            <div class = 'detail-row'>
                <span class = 'detail-label'>Income:</span>
                <span class = 'detail-value'>${Math.round(details.simd_score.AVG_INCOME || 0).toLocaleString()}</span>
            </div>
            <div class = 'detail-row'>
                <span class = 'detail-label'>Employment:</span>
                <span class = 'detail-value'>${Math.round(details.simd_score.AVG_EMPLOY || 0).toLocaleString()}</span>
            </div>
            <div class = 'detail-row'>
                <span class = 'detail-label'>Health:</span>
                <span class = 'detail-value'>${Math.round(details.simd_score.AVG_HEALTH || 0).toLocaleString()}</span>
            </div>
            <div class = 'detail-row'>
                <span class = 'detail-label'>Access:</span>
                <span class = 'detail-value'>${Math.round(details.simd_score.AVG_ACCESS || 0).toLocaleString()}</span>
            </div>
        </div>`

        // Nearest Open Space
        html += `<div class = 'detail-section' style = 'border-color: ${LAYER_CONFIG.spaces.color}; 
            color: ${LAYER_CONFIG.spaces.color}; background: ${LAYER_CONFIG.spaces.background}'>
            <h4>Nearest Green Space: </h4>
            <div class = 'detail-row'>
                <span class = 'detail-label'>${details.open_spaces.NAME || 'N/A'}</span>
            </div>
            <div class = 'detail-row'>
                <span class = 'detail-label'>Type:</span>
                <span class = 'detail-value'>${details.open_spaces.TYPE || 'N/A'}</span>
            </div>
            <div class = 'detail-row'>
                <span class = 'detail-label'>Area:</span>
                <span class = 'detail-value'>${details.open_spaces.AREA_HA?.toFixed(3) || 'N/A'} hectares</span>
            </div>
        </div>`
        
        // Nearest Community Centre
        html += `<div class = 'detail-section' style = 'border-color: ${LAYER_CONFIG.ccs.color}; 
            color: ${LAYER_CONFIG.ccs.color}; background: ${LAYER_CONFIG.ccs.background}'>
            <h4>Nearest Community Centre:</h4>
            <div class = 'detail-row'>
                <span class = 'detail-label'>${details.community_centres.CENTRE_NAME || 'N/A'}</span>
            </div>
            <div class = 'detail-row'>
                <span class = 'detail-value'>${details.community_centres.ADDRESS || 'N/A'}</span>
            </div>
        </div>`
        
        content.innerHTML = html
        panel.classList.add('active')
    }

    /**
     * Highlight related features (buffer, green space, community centre)
     */
    function highlightRelatedFeatures(details) {
        // Clear previous highlights
        Object.values(highlightedLayers).forEach(layer => {
            if (layer) map.removeLayer(layer)
        })
        highlightedLayers = {}
        
        // Find and highlight the corresponding buffer
        if (details.site_catchment && layersData.buffers) {
            const bufferFeature = layersData.buffers.features.find(
                f => f.properties.DES_REF === details.site_catchment.DES_REF
            )
            if (bufferFeature) {
                const style = LAYER_CONFIG.buffers
                highlightedLayers.buffer = L.geoJSON(bufferFeature, {
                    style: {...style},
                    onEachFeature: (feature, layer) => addFeatureInteractivity(feature, layer, 'buffers')
                }).addTo(map)
            }
        }

        // Find and highlight the corresponding green space
        if (details.open_spaces && layersData.spaces) {
            const spaceFeature = layersData.spaces.features.find(
                f => f.properties.OBJECTID_1 === details.open_spaces.OS_ID
            )
            if (spaceFeature) {
                const style = LAYER_CONFIG.spaces
                highlightedLayers.space = L.geoJSON(spaceFeature, {
                    style: {...style},
                    onEachFeature: (feature, layer) => addFeatureInteractivity(feature, layer, 'spaces')
                }).addTo(map)
            }
        }
        
        // Find and highlight the corresponding community centre
        if (details.community_centres && layersData.ccs) {
            const ccFeature = layersData.ccs.features.find(
                f => f.properties.CENTRE_ID === details.community_centres.CENTRE_ID
            )
            if (ccFeature) {
                const style = LAYER_CONFIG.ccs
                highlightedLayers.cc = L.geoJSON(ccFeature, {
                    pointToLayer: (feature, latlng) => {
                        return L.circleMarker(latlng, {
                            ...style,
                            radius: style.bigradius,
                            fillOpacity: 1
                        })
                    },
                    onEachFeature: (feature, layer) => addFeatureInteractivity(feature, layer, 'ccs', false)
                }).addTo(map)
            }
        }
        
    }

    /**
     * Clear site selection
     */
    function clearSelection() {
        // Remove selected site marker
        if (selectedSiteLayer) {
            map.removeLayer(selectedSiteLayer)
            selectedSiteLayer = null
        }
        
        // Remove highlighted layers
        Object.values(highlightedLayers).forEach(layer => {
            if (layer) map.removeLayer(layer)
        })
        highlightedLayers = {}
        
        // Hide details panel
        document.getElementById('site-details').classList.remove('active')
        
        selectedSite = null
    }

    /**
     * Create and add a layer to the map from stored data (applying filters if applicable)
     * @param {string} name - Layer name
     */
    function createLayer(name) {
        let data = layersData[name]

        // Apply filter for sites layer if set
        if (name === 'sites' && (sitesFilter || scoreMin > 0 || scoreMax < 1 || populationMin > 0 || populationMax < 30000)) {
            data = {
                type: 'FeatureCollection',
                features: data.features.filter(f => {
                    const matchesSearch = !sitesFilter || 
                        f.properties.ENT_TITLE.toLowerCase().includes(sitesFilter.toLowerCase()) ||
                        f.properties.DES_REF.toLowerCase().includes(sitesFilter.toLowerCase())
                    const matchesScore = (f.properties.FINAL_SCORE >= scoreMin) && 
                        (f.properties.FINAL_SCORE <= scoreMax)
                    const bufferPop = siteBufferPopulation[f.properties.DES_REF] || 0
                    const matchesPopulation = (bufferPop >= populationMin) && (bufferPop <= populationMax)
                    return matchesSearch && matchesScore && matchesPopulation
                })
            }
        }
        
        // ...existing code...

        // Apply filter for sites layer if set
        if (name === 'sites' && sitesFilter) {
            data = {
                type: 'FeatureCollection',
                features: data.features.filter(f => 
                    f.properties.ENT_TITLE.toLowerCase().includes(sitesFilter.toLowerCase())
                )
            }
        }

        // Apply type filter for spaces
        if (name === 'spaces' && activeSpaceTypes.size > 0) {
            data = {
                type: 'FeatureCollection',
                features: data.features.filter(f => 
                    activeSpaceTypes.has(f.properties.PAN65)
                )
            }
        }

        // Get style from config
        const style = LAYER_CONFIG[name] || {color: '#3388ff'}
        
        // Create GeoJSON layer with styling
        const layer = L.geoJSON(data, {
            style: style,
            pointToLayer: (feature, latlng) => {
                if (name === 'sites') {
                    const siteStyle = rankColoringEnabled ? 
                        {...LAYER_CONFIG.sites, fillColor: getRankColor(feature.properties.RANK)} :
                        LAYER_CONFIG.sites
                    
                    return L.circleMarker(latlng, {
                        ...siteStyle,
                        pane: 'sitesPane'
                    })
                } else if (name === 'ccs') {
                    return L.circleMarker(latlng, {
                        ...LAYER_CONFIG.ccs,
                        pane: 'sitesPane'
                    })
                }
                return L.marker(latlng)
            },
            onEachFeature: (feature, layer) => {
                // For sites, add click handler for selection
                if (name === 'sites') {
                    layer.on('click', () => {
                        selectSite(feature.properties.DES_REF, layer)
                    })
                    
                    // Add hover effect
                    layer.on('mouseover', function() {
                        if (selectedSiteLayer !== this) {
                            this.setStyle({fillOpacity: 1})
                        }
                    })
                    layer.on('mouseout', function() {
                        if (selectedSiteLayer !== this) {
                            this.setStyle({fillOpacity: style.fillOpacity})
                        }
                    })
                } else {
                    // For other layers, add interactivity with popup
                    addFeatureInteractivity(feature, layer, name)
                }
            }
        }).addTo(map)

        activeLayers[name] = layer
    }

    /**
     * Toggle spaces layer and all type sub-toggles
     */
    function toggleSpaces() {
        const spacesCheckbox = document.querySelector('input[data-layer = "spaces"]')
        const typeToggles = document.querySelectorAll('.space-type')
        const typeCheckboxes = document.querySelectorAll('.space-type input')
        const typesHeading = document.getElementById('types-heading')
        
        if (spacesCheckbox.checked) {
            // Show type toggles and heading
            typesHeading.style.display = 'block'
            typeToggles.forEach(toggle => toggle.classList.add('visible'))
            
            // Load data if not already loaded
            if (!layersData['spaces']) {
                fetch('/layer/spaces')
                    .then(r => r.json())
                    .then(data => {
                        layersData['spaces'] = data
                        // Enable all types
                        typeCheckboxes.forEach(cb => {
                            cb.checked = true
                            activeSpaceTypes.add(cb.dataset.type)
                        })
                        createLayer('spaces')
                    })
            } else {
                // Enable all types
                typeCheckboxes.forEach(cb => {
                    cb.checked = true
                    activeSpaceTypes.add(cb.dataset.type)
                })
                createLayer('spaces')
            }
        } else {
            // Hide type toggles and heading
            typesHeading.style.display = 'none'
            typeToggles.forEach(toggle => toggle.classList.remove('visible'))
            
            // Remove layer and clear types
            if (activeLayers['spaces']) {
                map.removeLayer(activeLayers['spaces'])
                delete activeLayers['spaces']
            }
            activeSpaceTypes.clear()
            typeCheckboxes.forEach(cb => cb.checked = false)
        }
    }

    /**
     * Toggle individual space type
     */
    function toggleSpaceType(spaceType) {
        const checkbox = document.querySelector(`input[data-type="${spaceType}"]`)
        
        if (checkbox.checked) {
            activeSpaceTypes.add(spaceType)
        } else {
            activeSpaceTypes.delete(spaceType)
        }
        
        // Recreate spaces layer with updated filter
        if (activeLayers['spaces']) {
            map.removeLayer(activeLayers['spaces'])
            delete activeLayers['spaces']
        }
        
        if (activeSpaceTypes.size > 0) {
            createLayer('spaces')
        }
    }

    /**
     * Generate HTML popup content for non-site layers
     */
    function infoPopup(properties, layerName) {
        const popupTemplates = {
            buffers: () => `
                <h3>Buffer of: ${properties.ENT_TITLE}</h3>
                <b>Population in buffer:</b> ${Math.round(properties.Population).toLocaleString()}<br>
                <b>Number of bus routes in buffer:</b> ${Math.round(properties.No__of_Bus).toLocaleString()}<br>
            `,
            spaces: () => `
                <h3>${properties.NAME}</h3>
                <b>Type:</b> ${properties.PAN65}<br>
                ${properties.CLASSIFICA ? `<b>Classification:</b> ${properties.CLASSIFICA}<br>` : ''}
                <b>NP Name:</b> ${properties.NP_Name}<br>
                ${properties.YEAROPEN > 1000 ? `<b>Year Opened:</b> ${parseInt(properties.YEAROPEN, 10)}<br>` : ''}
                <b>Area:</b> ${properties.Area_ha.toLocaleString()} hectares <br>
            `,
            ccs: () => `
                <h3>${properties.CENTRE_NAME}</h3>
                <b>Address:</b> ${properties.ADDRESS}<br>
                ${properties.LISTED ? `<b>Listed:</b> ${properties.LISTED}<br>` : ''}
                ${properties.LINK ? `<a href=${properties.LINK} target='_blank'>Centre Website</a>` : ''}
            `
        }
        
        return popupTemplates[layerName] ? popupTemplates[layerName]() : '<p>No details available</p>'
    }

    /**
     * Toggle layer visibility on the map
     */
    function toggle(name) {
        if (activeLayers[name]) {
            map.removeLayer(activeLayers[name])
            delete activeLayers[name]
        } else {
            if (!layersData[name]) {
                fetch(`/layer/${name}`)
                    .then(r => r.json())
                    .then(data => {
                        layersData[name] = data
                        if (name === 'buffers') {
                            buildBufferPopulationMap()
                        }
                        createLayer(name)
                    })
            } else {
                createLayer(name)
            }
        }
        
        // Show/hide rank coloring and buffers toggles based on sites selection
        if (name === 'sites') {
            const buffersToggle = document.getElementById('buffers-toggle')
            const rankToggle = document.getElementById('rank-coloring-toggle')
            const rankColorbar = document.getElementById('rank-colorbar-container')
            const buffersCheckbox = document.querySelector('input[data-layer = "buffers"]')
            
            if (activeLayers['sites']) {
                buffersToggle.classList.add('visible')
                rankToggle.style.display = 'block'
                rankColorbar.style.display = rankColoringEnabled ? 'block' : 'none'
            } else {
                buffersToggle.classList.remove('visible')
                rankToggle.style.display = 'none'
                rankColorbar.style.display = 'none'
                rankColoringEnabled = false
                document.getElementById('rank-coloring-checkbox').checked = false
                // Turn off buffers if sites is turned off
                if (activeLayers['buffers']) {
                    buffersCheckbox.checked = false
                    map.removeLayer(activeLayers['buffers'])
                    delete activeLayers['buffers']
                }
            }
        }
    }

    /**
     * Update score filter values and refresh sites layer
     */
    function updateScoreFilter() {
        scoreMin = parseFloat(document.getElementById('score-min').value)
        scoreMax = parseFloat(document.getElementById('score-max').value)
        
        // Ensure min doesn't exceed max and vice versa
        if (scoreMin > scoreMax) {
            [scoreMin, scoreMax] = [scoreMax, scoreMin]
            document.getElementById('score-min').value = scoreMin
            document.getElementById('score-max').value = scoreMax
        }
        
        document.getElementById('min-value').textContent = scoreMin.toFixed(2)
        document.getElementById('max-value').textContent = scoreMax.toFixed(2)
        
        // Refresh sites layer if active
        if (activeLayers['sites']) {
            map.removeLayer(activeLayers['sites'])
            delete activeLayers['sites']
            createLayer('sites')
        }
    }

    /**
     * Reset all filters to default ranges
     */
    function resetScoreFilter() {
        document.getElementById('score-min').value = 0
        document.getElementById('score-max').value = 1
        scoreMin = 0
        scoreMax = 1
        document.getElementById('min-value').textContent = '0.00'
        document.getElementById('max-value').textContent = '1.00'
        
        document.getElementById('pop-min').value = 0
        document.getElementById('pop-max').value = 30000
        populationMin = 0
        populationMax = 30000
        document.getElementById('pop-min-value').textContent = '0'
        document.getElementById('pop-max-value').textContent = '30,000'
        
        if (activeLayers['sites']) {
            map.removeLayer(activeLayers['sites'])
            delete activeLayers['sites']
            createLayer('sites')
        }
    }

    /**
     * Handle sites search
     */
    function searchSites() {
        sitesFilter = document.getElementById('site-search').value
        const sitesCheckbox = document.querySelector('input[data-layer = "sites"]')
        
        // Remove existing sites layer
        if (activeLayers['sites']) {
            map.removeLayer(activeLayers['sites'])
            delete activeLayers['sites']
        }

        // Load and create filtered sites layer
        const loadAndCreateSites = () => {
            createLayer('sites')
            sitesCheckbox.checked = true
        }

        if (layersData['sites']) {
            loadAndCreateSites()
        } else {
            fetch('/layer/sites')
                .then(r => r.json())
                .then(data => {
                    layersData['sites'] = data
                    loadAndCreateSites()
                })
        }
    }

    // Load plasma colormap from server
    fetch('/plasma')
        .then(r => r.json())
        .then(data => {
            plasmaData = data
            generateRankColorbar()
        })

    // Auto-load layers that are defaultOn
    document.querySelectorAll('input[type = "checkbox"]').forEach(cb => {
        const layerName = cb.dataset.layer
        if (LAYER_CONFIG[layerName]?.defaultOn) {
            if (layerName === 'spaces') {
                toggleSpaces()
            } else if (layerName === 'buffers') {
                toggle(layerName)
            } else {
                toggle(layerName)
            }
        }
    })

    // Build buffer population map after buffers are loaded
    fetch('/layer/buffers')
        .then(r => r.json())
        .then(data => {
            layersData['buffers'] = data
            buildBufferPopulationMap()
        })
        .catch(err => console.error('Error loading buffers:', err))

    // Show sub toggle if sites is initially on
    if (LAYER_CONFIG['sites']?.defaultOn) {
        document.getElementById('buffers-toggle').classList.add('visible')
        document.getElementById('rank-coloring-toggle').style.display = 'block'
        document.getElementById('rank-colorbar-container').style.display = 'none'
    }

    // Apply custom labels and colors from config
    document.querySelectorAll('.layer-label').forEach(label => {
        const layerName = label.dataset.layer
        const config = LAYER_CONFIG[layerName]
        
        if (config) {
            label.textContent = config.label
            label.style.color = config.color
            label.style.fontWeight = 'bold'
            const checkbox = label.previousElementSibling
            checkbox.checked = config.defaultOn || false
        }
    })

</script>
</body>
</html>